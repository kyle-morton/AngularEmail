-uses the single page application idealogy (0 page refreshes)
	the html needed is injected into the ng-view element

-angular.module('myApp', []) -> creates new module (NAMESPACE) called 'myApp' and returns
								it so you can assign it vars, functions
							 -> [] is used to path names of other modules as dependencies
							 -> with the array arg, the function becomes a getter for 'myApp'
							 
-routing -> use $routeProvider to inject the correct html when certain route reached
		    EX. when at /inbox, inject inbox.html which inits it's controller
			
$routeProvider is a seperate library from core angular, must be included in project file
***$routeProvider version should MATCH your angular version

-once $routeProvided included, we can use ngRoute and pass as dependency in our module!
 	EX. var app = angular.module('app', [
								'ngRoute'
								]);
								
-you can dynamically assign controllers to html elements

**modules have a .config() function that is run before most other function callbacks.
	-This is where we can config the routes, set up controllers, etc!
	
	//app.config(function() {/*....*/});								
	
	
--REM: good controller will have as little logic in it as possible.
--Used for binding view/model and small helper functions not needed elsewhere

Factory---
-commonly used to communicate with server-side APIs
-create reusable features and code blocks througout app
*API comm and modal storage/updates!

-create using app.factory (REM: factory creates an object that has the useful functions in it)
*GOOD IDEA -> use exports objects to store vars, functions that you actually want returned! 
REM: scoping can be confusing to defug if not explicit

app.factory('InboxFactory', function InboxFactory ($http) {
   var exports = {};

   exports.getMessages = function () {
      return $http.get('json/emails.json')
         .error(function (data) {
            console.log('There was an error!', data);
      });
   };

   return exports;
});

-notice how the return from $http.get() has function call .error()
-this is using the Promise API -> no object at time of call, but 
-PROMISED an object on return. act accordingly.


Promises 
- used heavily in angular, especially for things that take time (HTTP Requests for ex)
- use $q ($http is based off $q)
	- create the promise and pass it 2 callback functions for when:
		1) promise returned as expected (success)
		2) not returned as expected (error)
	ex) var deferred = $q.defer();
		deferred.promise.then(
			function whenThingsGoSunny(){}, //success
			function whenThingsDontGoSoSunny(){} //failure
		)
	
-$http does something similar with success, error functions on ajax requests
	$http({method: 'GET', url: '/someUrl'})
	.success(function(data, status, headers, config) {
		// this callback will be called asynchronously
		// when the response is available
	})
	.error(function(data, status, headers, config) {
		// called asynchronously if an error occurs
		// or server returns response with an error status.
	});
